<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>demo</title>

    <style>
      * {
        padding: 0;
        margin: 0;
      }
      #root {
        width: 100%;
        height: 100vh;
        display: flex;
        position: relative;
        justify-content: center;
        align-items: center;
      }
      #result-cot {
        position: absolute;
        top: 30px;
        left: 30px;
      }
      #core {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: pink;
      }
    </style>
  </head>
  <body>
    <script>
      // onLoad当所有资源加载完毕在执行以下函数，避免获取DOM抛错
      window.onload = () => {
        const node = document.getElementById("core"),
          cumulateNode = document.querySelector("p"),
          speedNode = cumulateNode.nextElementSibling;
        let frameCount = 0, // 用于记录定时器是否执行
          startTime = null, // 鼠标开始移动的起始时间
          timerTask = null, // 定时器实列
          degrees = 0, // 鼠标旋转总共度数
          cumulate = 0, // 鼠标旋转总圈数
          centerPlace = { x: null, y: null }, // 中心点位置
          startPlace = { x: null, y: null }, // 鼠标当前位置
          endPlace = { x: null, y: null }, // 鼠标结束位置
          direct = null; // 是否是顺逆时针
        const computedDistance = (node, mouseX, mouseY) => {
          const { x, y, left, top } = node.getBoundingClientRect(),
            distance = Math.sqrt((mouseX - left) * (mouseX - left) + (mouseY - top) * (mouseY - top));
          centerPlace.x = x; // 这里考虑到中心点网页响应式采取实时赋值
          centerPlace.y = y;
          return distance;
        };
        const computedClockwiseOrCounterclockwise = (x, y) => {
          startPlace.x = x;
          startPlace.y = y;
          setTimeout(() => {
            endPlace.x = x;
            endPlace.y = y;
          }, 100);
          const AB = {},
            AC = {};
          AB.X = startPlace.x - centerPlace.x;
          AB.Y = startPlace.y - centerPlace.y;
          AC.X = endPlace.x - centerPlace.x;
          AC.Y = endPlace.y - centerPlace.y; // 分别求出AB,AC的向量坐标表示
          direct = AB.X * AC.Y - AB.Y * AC.X;
          // 这里计算旋转度数
          let lengthAB = Math.sqrt(Math.pow(centerPlace.x - startPlace.x, 2) + Math.pow(centerPlace.y - startPlace.y, 2)),
            lengthAC = Math.sqrt(Math.pow(centerPlace.x - endPlace.x, 2) + Math.pow(centerPlace.y - endPlace.y, 2)),
            lengthBC = Math.sqrt(Math.pow(startPlace.x - endPlace.x, 2) + Math.pow(startPlace.y - endPlace.y, 2));
          let cosA = (Math.pow(lengthAB, 2) + Math.pow(lengthAC, 2) - Math.pow(lengthBC, 2)) / (2 * lengthAB * lengthAC); //   余弦定理求出旋转角
          let angleA = Math.round((Math.acos(cosA) * 180) / Math.PI);
          const ClockwiseOrCounterclockwise = +direct < 0;
          //叉乘结果为负表示顺时针旋转，
          if (ClockwiseOrCounterclockwise) {
            // 当前旋转角度大于20我们才去加，这里避免一些小角度的干扰
            if (angleA > 20) {
              degrees += angleA;
            }
            if (degrees > 3600) {
              cumulate++;
              degrees = 0;
            }
          }
          return ClockwiseOrCounterclockwise; // 这里判断逆时针还是顺时针判断是否走以下逻辑
        };
        document.addEventListener("mousemove", event => {
          const ClockwiseOrCounterclockwise = computedClockwiseOrCounterclockwise(event.pageX, event.pageY);
          if (!ClockwiseOrCounterclockwise) return;
          if (timerTask) {
            clearTimeout(timerTask);
            timerTask = null;
          }
          frameCount++;
          const currentdistance = computedDistance(node, event.clientX, event.clientY).toFixed(2), // 当前鼠标在的x，y点围绕中心点的半径
            volume = currentdistance * 2 * Math.PI; // 移动距离
          if (frameCount >= 1) {
            const timer = new Date().getTime() - startTime;
            const speed = (volume / timer).toFixed(2); // 帧数
            speedNode.innerHTML = `Speed:${speed}`;
            cumulateNode.innerHTML = `Cumulate:${cumulate}`;
            if (!timerTask) {
              timerTask = setTimeout(() => {
                speedNode.innerHTML = `Speed:0`;
                frameCount = 0;
                startTime = new Date().getTime();
              }, 800);
            }
          }
        });
        startTime = new Date().getTime();
      };
    </script>
    <div id="root">
      <details id="result-cot" open>
        <summary>computed</summary>
        <p>Cumulate:0</p>
        <p>Speed:0</p>
      </details>
      <article id="core"></article>
    </div>
  </body>
</html>
